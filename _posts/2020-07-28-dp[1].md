---
layout: post
title:  "[Python] 백준 알고리즘 dp : 문제풀이 [1]"
date:   2020-07-28
desc: " "
keywords: "python, dp, algorithm"
categories: [Python]
tags: [python, algorithm, dp]
icon: icon-html
---

애증의 `DP` ,,,

사실 DP는 `완전 탐색` 의 효율적인 version인 셈인데,,,

간단한 예제들로 몇개만 풀어봤당



<br>


우선 가장 기본이 되는 이항개수 구하는 문제!


B라는 list variable을 이용하여 memoization했다.


```python
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    # ///////////////////////////////////////////////////////////////////////////////////
    n, k, b = map(int, input().split())
    B = []
    for i in range(n+1):
    	B.append( [0] * (i+1)  )
    	for j in range(min(a,i)+1):
       		if j==0 or j == i: B[i][j] = 1
            else: B[i][j]  = B[i-1][j-1]  + B[i-1][j]
	print(B[i][j])
  ```


<br>


[1463: 1로 만들기](https://www.acmicpc.net/problem/1463)


  ```python
  def make_one(a):
    a = int(a)
    if a == 2 or a == 3 or a == 1:
        m[a] = 1
    elif m[a]==0:
        temp = []
        if a%3 == 0:
            temp.append(1+make_one(a/3))
        if a%2 == 0:
            temp.append(1+make_one(a/2))
        temp.append(1+make_one(a-1))
        m[a] = min(temp)
    return m[a]

n = int(input()) # 입력받은 값
m = [0]*(n+1)
print(make_one(n))
  ```


<br>

[11726: 2xn 타일 ](https://www.acmicpc.net/problem/11726)

  ```python
  ```


  <br>

[11727: 2xn 타일2](https://www.acmicpc.net/problem/11727)
```python
```


<br>

[2156: 포도주 시식](https://www.acmicpc.net/problem/2156)
```python
```


<br>

[2011: 암호코드](https://www.acmicpc.net/problem/2011)

```python
```
