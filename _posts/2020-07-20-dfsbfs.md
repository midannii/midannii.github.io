---
layout: post
title:  "[Python] 백준 알고리즘 graph : DFS,BFS + 문제풀이  "
date:   2020-07-20
desc: " "
keywords: "python, chatbot, pet"
categories: [Python]
tags: [python, chatbot]
icon: icon-html
---

이번 한 주 동안은 `DFS`, `BFS` 를 간단하게 구현해보고

백준에서 알고리즘 문제를 풀어봤다!



<br>



우선, tree의 vertex, edge 정보를 담은 list를 만들고


```python
vertexList = [0,1,2,3,4,5,6]
edgeList = [(0,1), (0,2), (1,0), (1,3), (2,0), (2,4), (2,5), (3,1), (4,2), (4,6), (5,2), (6,4)]

adjencyList = [[] for vertex in vertexList]

for edge in edgeList: #각각 vertex 0 ~ 6가 어떤 vertex와 edge를 가지고 있는지
    adjencyList[edge[0]].append(edge[1])
```


## 1. BFS

```python
# BFS
import queue
q=queue.Queue()
q.put(0)
visitedVertex = []

while q.qsize():
    current = q.get()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            q.put(neighbor)
    visitedVertex.append(current)
print(visitedVertex)
```

## 2. DFS

```python
# DFS
stack = [0]
visitedVertex = []

while stack:
    current = stack.pop()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            stack.append(neighbor)
    visitedVertex.append(current)

print(visitedVertex)
```

<br>

## 3. boj

[1260: BFS DFS](https://www.acmicpc.net/problem/1260) : DFS와 BFS


```python
# 첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다
n, m, v = map(int, input().split())
edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])
for adj in adjencyList:
    if len(adj)>1:
        adj.sort()
for adj in adjencyList:
    if len(adj)>1:
        adj.sort(reverse=True)        
# DFS
stack = [v]
visitedVertex = []
while stack:
    current = stack.pop()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            stack.append(neighbor)
    visitedVertex.append(current)
    if len(visitedVertex) == n:
        break
print("DFS : ")
for visited in visitedVertex:
    print(visited, end = ' ')
print()

# BFS
import queue
for adj in adjencyList:
    if len(adj)>1:
        adj.sort()
q=queue.Queue()
q.put(v)
visitedVertex = []
while True:
    current = q.get()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            q.put(neighbor)
    visitedVertex.append(current)
    if len(visitedVertex) == n:
        break
print("BFS: ")
for visited in visitedVertex:
    print(visited, end = ' ')
print()
```

런타임 에러는 왜 나는걸까 ㅠㅠㅠ





<br>

[11724: 연결 요소의 개수](https://www.acmicpc.net/problem/11724)


```python
# 방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성
def count_cc(edgeL, vertexL, adjencyL, startpoint):
    visitedVertex = []
    stack = [startpoint]
    while len(stack)>0:
        current = stack.pop()
        for neighbor in adjencyList[current]:
            if not neighbor in visitedVertex:
                stack.append(neighbor)
        visitedVertex.append(current)
    if len(visitedVertex) == n:
        return 1
    else:
        for vertex in vertexL:
            if vertex not in visitedVertex:
                startpoint = vertex
                break
        return 1+count_cc(edgeL, vertexL, adjencyL, startpoint)

# 첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2)
# 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.

n, m = map(int, input().split())

edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])

print(count_cc(edgeList, vertexList, adjencyList, vertexList[0]))
```

처음에는 이렇게 풀었는데 자꾸 recursion error가 뜨고, 백준에서도 시간 초과가 뜨더라 ㅠㅠ

근데 그럴만해,,, 재귀함수 안에 while을 넣었으니 시간복잡도가 거진 O(N^2) 겠지 모,,,



```python
n, m = map(int, input().split())

edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])
cc = 0
stack = [vertexList[0]]
visitedVertex = []
while len(visitedVertex) != n:
    while stack:
        current = stack.pop()
        for neighbor in adjencyList[current]:
            if not neighbor in visitedVertex:
                stack.append(neighbor)
            visitedVertex.append(current)
        if len(visitedVertex) == n:
            break
    cc += 1
    for vertex in vertexList:
        if vertex not in visitedVertex:
            stack = [vertex]
print(cc)
```


recursion 안쓴 버전도 만들었는데 자꾸 시간 초과가 뜨더라구요 ㅠㅠㅠ 엉엉




그래서 이렇게 두 문제를 풀고 나서, 다른 분들의 코드를 보니까

내가 엄청 매우 굉장히 무겁게 문제를 풀고 있다는 걸 알아냈다,,,,

다른 분들의 코드는 진짜 가볍더라구용,,,



```python
# 출처 : https://velog.io/@devjuun_s/%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B0%9C%EC%88%98-%EB%B0%B1%EC%A4%80-11724%EB%B2%88python
import sys
sys.setrecursionlimit(10000)

def dfs(v):
    visited[v] = True
    for e in adj[v]:
        if not visited[e]:
            dfs(e)

N, M = map(int, input().split())
adj = [[] for _ in range(N + 1)]
visited = [False] * (N + 1)
count = 0

for _ in range(M):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

for j in range(1, N + 1):
    if not visited[j]:
        dfs(j)
        count += 1

print(count)
```

<br>




[10451: 순열 사이클](https://www.acmicpc.net/problem/10451) 이 문제는 문제 이해가 너무 안되도라,,

순열을 배열로 나타낸다는 말이 처음에 이해가 안되었지만 무난하게 풀었당


 ```python
 def dfs(v):
    visited[v] = True
    for e in adj[v]:
        if not visited[e]:
            dfs(e)
result = []
for i in range(2): #t번 반복
    cc = 0
    n = int(input()) # 순열의 개수
    adj = [[] for _ in range(n+1)]
    permut = [ _ for _ in map(int, input().split())]
    for i in range(n):
        adj[i+1].append(permut[i])
    visited = [False] * (n+1)
    for j in range(1, n+1):
        if not visited[j]:
            dfs(j)
            cc += 1
    result.append(cc)

#결과 출력
for re in result:
    print(re)
 ```

<br>

[2331](https://www.acmicpc.net/problem/2331)

```python
def calcul(a, b):
    a = str(a)
    b = int(b)
    total = 0
    for n in a:
        total += (pow(int(n),b))
    return total

a, b = input().split()
num_list = [int(a)]
while True:
    result = calcul(a,b)
    if result in num_list:
        break
    num_list.append(result)
    a = result

print(num_list.index(result))
```

<br>



[2667: 단지 번호 붙이기](https://www.acmicpc.net/problem/2667)


마찬가지로 처음에는 조금 헷갈렸지만, adjencyMatrix를 생각하니까 좀 이해가 되더라.

그리고 아래 두 문제들도 비슷한 개념이도라구


```python
def count_house(houses,i,j, visited): # i,j는 index
    '''
    왼쪽, 위 에서부터 시작하므로, 이동은 무조건 오른쪽, 왼쪽, 아래
    그러므로 아래로 더 못내려 가거나, 오른쪽으로 더 못가는 경우만 생각하기
    '''
    result = 0
    visited[i][j] = True
    if houses[i][j]==1:
        result+=1
    else:
        return result
    if i == n-1:
        if j==n-1:  #오른쪽, 아래로 못갈 때 (더이상 이동 x)
            return result
        else: # 오른쪽으로 못갈 때
            return result + count_house(houses, i, j+1, visited)
    else:
        return result + count_house(houses, i+1, j, visited) + count_house(houses, i, j+1, visited)

n = int(input())
houses = []
for i in range(n):
    houses.append([ _ for _ in input()])
    for j in range(n):
        houses[i][j] = int(houses[i][j])
visited = [[False for _ in range(n)] for _ in range(n)]
count = [] # 각 단지의 house 개수
for k in range(n):
    for m in range(n):
        if not visited[k][m]:
            count.append(count_house(houses, k, m, visited))
result = []
for c in count:
    if c!=0:
        result.append(c)
result.sort()
for re in result:
    print(re)
```


이 문제는 dfs 랑 연결 요소가 섞인 문제당


즉, **상하좌우의 방향으로 1-1 끼리 Edge들이 연결되어 있는 트리** 로 접근했다.


[4963: 섬의 개수](https://www.acmicpc.net/problem/4963)도 같은 유형이당


<br>

+


난 런타임 에러가 정말 싫엉 히히

자꾸 recursion limit 걸리면



```python
import sys
sys.setrecursionlimit(2000)
```



이렇게 limit를 풀어주세용





<br>

[7576: 토마토](https://www.acmicpc.net/problem/7576) 문제는 저번에 도전했다가 결국 그래도 뒀던 것,,,

풀었는데 아직도 너무 어렵다 또르륵



```python
# 숫자를 입력받기
m, n = map(int, input().split())

# 초기 상태
tomatoes = []
green = 0
red = 0
day = 0
for i in range(n):
    tomatoes.append(input().split())
    for j in range(m):
        tomatoes[i][j] = int(tomatoes[i][j])
        if tomatoes[i][j] == 0:
            green+=1
        elif tomatoes[i][j] == 1:
            red+=1
            reds.append([i,j])
total = green+red

checked = [[False for _ in range(m)]for _ in range(n)]
reds = []

def ripen(tomatoes, i, j, checked):
    '''
    input: i와 j는 시작 index(익은 부분부터 시작)
    output: 다익는데 걸리는 날짜
    '''
    print(str(i)+"&"+str(j)+"th")
    if i<n and j<m and tomatoes[i][j] != -1 and checked[i][j] == False:
        checked[i][j] = True
        red+=1
        if i == 0:
            if j == 0:
                return 1+ripen(tomatoes, i, j+1, checked)+ripen(tomatoes, i+1, j, checked)
            elif j == n-1:
                return 1+ripen(tomatoes, i, j-1, checked)+ripen(tomatoes, i+1, j, checked)
            else:
                return 1+ripen(tomatoes, i, j+1, checked)+ripen(tomatoes, i, j-1, checked)+ripen(tomatoes, i+1, j, checked)
        elif i == m-1:
            if j == 0:
                return 1+ripen(tomatoes, i, j+1, checked)+ripen(tomatoes, i-1, j, checked)
            elif j == n-1:
                return 1+ripen(tomatoes, i, j-1, checked)+ripen(tomatoes, i-1, j, checked)
            else:
                return 1+ripen(tomatoes, i, j+1, checked)+ripen(tomatoes, i, j-1, checked)+ripen(tomatoes, i-1, j, checked)
        else:
            return 1+ripen(tomatoes, i, j+1, checked)+ripen(tomatoes, i+1, j, checked)+ripen(tomatoes, i-1, j, checked) + ripen(tomatoes, i, j-1, checked)

for i in range(len(reds)):
    a,b = reds[i]
    day = ripen(tomatoes, a, b, checked)

if red == total: print(day)
else: print(-1)       
```

<br>

[2178: 미로찾기](https://www.acmicpc.net/problem/2178)
```python
```

<br>


[2146](https://www.acmicpc.net/problem/2146)
```python
```

<br>


[1991](https://www.acmicpc.net/problem/1991)
```python
```

<br>


[1967](https://www.acmicpc.net/problem/1967)
```python
```

<br>
