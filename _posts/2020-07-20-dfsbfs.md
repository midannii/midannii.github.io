---
layout: post
title:  "[Python] 백준 알고리즘 graph : DFS,BFS + 문제풀이  "
date:   2020-07-20
desc: " "
keywords: "python, chatbot, pet"
categories: [Python]
tags: [python, chatbot]
icon: icon-html
---

이번 한 주 동안은 `DFS`, `BFS` 를 간단하게 구현해보고

백준에서 알고리즘 문제를 풀어봤다!



<br>



우선, tree의 vertex, edge 정보를 담은 list를 만들고


```python
vertexList = [0,1,2,3,4,5,6]
edgeList = [(0,1), (0,2), (1,0), (1,3), (2,0), (2,4), (2,5), (3,1), (4,2), (4,6), (5,2), (6,4)]

adjencyList = [[] for vertex in vertexList]

for edge in edgeList: #각각 vertex 0 ~ 6가 어떤 vertex와 edge를 가지고 있는지
    adjencyList[edge[0]].append(edge[1])
```


## 1. BFS

```python
# BFS
import queue
q=queue.Queue()
q.put(0)
visitedVertex = []

while q.qsize():
    current = q.get()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            q.put(neighbor)
    visitedVertex.append(current)
print(visitedVertex)
```

## 2. DFS

```python
# DFS
stack = [0]
visitedVertex = []

while stack:
    current = stack.pop()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            stack.append(neighbor)
    visitedVertex.append(current)

print(visitedVertex)
```

<br>

## 3. boj

[1260: BFS DFS](https://www.acmicpc.net/problem/1260) : DFS와 BFS


```python
# 첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다
n, m, v = map(int, input().split())
edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])
for adj in adjencyList:
    if len(adj)>1:
        adj.sort()
for adj in adjencyList:
    if len(adj)>1:
        adj.sort(reverse=True)        
# DFS
stack = [v]
visitedVertex = []
while stack:
    current = stack.pop()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            stack.append(neighbor)
    visitedVertex.append(current)
    if len(visitedVertex) == n:
        break
print("DFS : ")
for visited in visitedVertex:
    print(visited, end = ' ')
print()

# BFS
import queue
for adj in adjencyList:
    if len(adj)>1:
        adj.sort()
q=queue.Queue()
q.put(v)
visitedVertex = []
while True:
    current = q.get()
    for neighbor in adjencyList[current]:
        if not neighbor in visitedVertex:
            q.put(neighbor)
    visitedVertex.append(current)
    if len(visitedVertex) == n:
        break
print("BFS: ")
for visited in visitedVertex:
    print(visited, end = ' ')
print()
```

런타임 에러는 왜 나는걸까 ㅠㅠㅠ





<br>

[11724: 연결 요소의 개수](https://www.acmicpc.net/problem/11724)


```python
# 방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성
def count_cc(edgeL, vertexL, adjencyL, startpoint):
    visitedVertex = []
    stack = [startpoint]
    while len(stack)>0:
        current = stack.pop()
        for neighbor in adjencyList[current]:
            if not neighbor in visitedVertex:
                stack.append(neighbor)
        visitedVertex.append(current)
    if len(visitedVertex) == n:
        return 1
    else:
        for vertex in vertexL:
            if vertex not in visitedVertex:
                startpoint = vertex
                break
        return 1+count_cc(edgeL, vertexL, adjencyL, startpoint)

# 첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2)
# 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.

n, m = map(int, input().split())

edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])

print(count_cc(edgeList, vertexList, adjencyList, vertexList[0]))
```

처음에는 이렇게 풀었는데 자꾸 recursion error가 뜨고, 백준에서도 시간 초과가 뜨더라 ㅠㅠ

근데 그럴만해,,, 재귀함수 안에 while을 넣었으니 시간복잡도가 거진 O(N^2) 겠지 모,,,



```python
n, m = map(int, input().split())

edgeList = []
vertexList = []
for i in range(m):
    temp = input() # 간선 정보
    a,b = temp.split()
    vertexList.append(int(a))
    vertexList.append(int(b))
    edgeList.append((int(a), int(b)))
    edgeList.append((int(b), int(a)))
vertexList = list(set(vertexList))
adjencyList = [[] for i in range(1001)]
for edge in edgeList:
    adjencyList[edge[0]].append(edge[1])
cc = 0
stack = [vertexList[0]]
visitedVertex = []
while len(visitedVertex) != n:
    while stack:
        current = stack.pop()
        for neighbor in adjencyList[current]:
            if not neighbor in visitedVertex:
                stack.append(neighbor)
            visitedVertex.append(current)
        if len(visitedVertex) == n:
            break
    cc += 1
    for vertex in vertexList:
        if vertex not in visitedVertex:
            stack = [vertex]
print(cc)
```


recursion 안쓴 버전도 만들었는데 자꾸 시간 초과가 뜨더라구요 ㅠㅠㅠ 엉엉




그래서 이렇게 두 문제를 풀고 나서, 다른 분들의 코드를 보니까

내가 엄청 매우 굉장히 무겁게 문제를 풀고 있다는 걸 알아냈다,,,,

다른 분들의 코드는 진짜 가볍더라구용,,,



```python
# 출처 : https://velog.io/@devjuun_s/%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B0%9C%EC%88%98-%EB%B0%B1%EC%A4%80-11724%EB%B2%88python
import sys
sys.setrecursionlimit(10000)

def dfs(v):
    visited[v] = True
    for e in adj[v]:
        if not visited[e]:
            dfs(e)

N, M = map(int, input().split())
adj = [[] for _ in range(N + 1)]
visited = [False] * (N + 1)
count = 0

for _ in range(M):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

for j in range(1, N + 1):
    if not visited[j]:
        dfs(j)
        count += 1

print(count)
```

<br>




[10451: 순열 사이클](https://www.acmicpc.net/problem/10451) 이 문제는 문제 이해가 너무 안되도라,,

순열을 배열로 나타낸다는 말이 처음에 이해가 안되었지만 무난하게 풀었당


 ```python
 def dfs(v):
    visited[v] = True
    for e in adj[v]:
        if not visited[e]:
            dfs(e)
result = []
for i in range(2): #t번 반복
    cc = 0
    n = int(input()) # 순열의 개수
    adj = [[] for _ in range(n+1)]
    permut = [ _ for _ in map(int, input().split())]
    for i in range(n):
        adj[i+1].append(permut[i])
    visited = [False] * (n+1)
    for j in range(1, n+1):
        if not visited[j]:
            dfs(j)
            cc += 1
    result.append(cc)

#결과 출력
for re in result:
    print(re)
 ```

<br>

[2331](https://www.acmicpc.net/problem/2331)

```python
def calcul(a, b):
    a = str(a)
    b = int(b)
    total = 0
    for n in a:
        total += (pow(int(n),b))
    return total

a, b = input().split()
num_list = [int(a)]
while True:
    result = calcul(a,b)
    if result in num_list:
        break
    num_list.append(result)
    a = result

print(num_list.index(result))
```

<br>

[9466](https://www.acmicpc.net/problem/9466)

```python
```
<br>

[2667](https://www.acmicpc.net/problem/2667)

```python
```

<br>

[4963](https://www.acmicpc.net/problem/4963)

```python
```

<br>

[7576](https://www.acmicpc.net/problem/7576)

```python
```

<br>

[2178](https://www.acmicpc.net/problem/2178)
```python
```

<br>


[2146](https://www.acmicpc.net/problem/2146)
```python
```

<br>


[1991](https://www.acmicpc.net/problem/1991)
```python
```

<br>


[1967](https://www.acmicpc.net/problem/1967)
```python
```

<br>
