---
layout: post
title:  "[ëª¨ë‘ë¥¼ ìœ„í•œ ë”¥ëŸ¬ë‹2 Pytorch] Softmax Classification  "
date:   2021-01-15
categories: ML
---

ğŸ³ reference: <ëª¨ë‘ë¥¼ ìœ„í•œ ë”¥ëŸ¬ë‹ 2: pytorch> Lab6

```python

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
```



## Softmax

softí•˜ê²Œ maxê°’ì„ ë½‘ì•„ì£¼ëŠ” í•¨ìˆ˜

![fig](https://render.githubusercontent.com/render/math?math=P%28class%3Di%29%20%3D%20%5Cfrac%7Be%5Ei%7D%7B%5Csum%20e%5Ei%7D&mode=display)

```python
z = torch.FloatTensor([1, 2, 3])
hypothesis = F.softmax(z, dim=0)
print(hypothesis)
# tensor([0.0900, 0.2447, 0.6652])
```

ì›ë˜ maxëŠ” 0,0,1ì„ ì¶œë ¥í•˜ì§€ë§Œ softmaxëŠ” í•©ì³ì„œ 1ì´ ë˜ë„ë¡ ì¶œë ¥í•¨



## Cross Entropy

ë‘ í™•ë¥  ë¶„í¬ê°€ ì–¼ë§ˆë‚˜ ë¹„ìŠ·í•œì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í•¨ìˆ˜

![fig](https://miro.medium.com/max/2690/1*lDgFCR7SxMcGRzInj0AC9g.png)

### cross entropy loss


![fig](https://render.githubusercontent.com/render/math?math=L%20%3D%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum%20-%20y%20%5Clog%28%5Chat%7By%7D%29&mode=display)

```python
z = torch.rand(3, 5, requires_grad=True) # 3ê°œì˜ sample, 5ê°œì˜ class
hypothesis = F.softmax(z, dim=1)
print(hypothesis)
#tensor([[0.2645, 0.1639, 0.1855, 0.2585, 0.1277],
#        [0.2430, 0.1624, 0.2322, 0.1930, 0.1694],
#        [0.2226, 0.1986, 0.2326, 0.1594, 0.1868]], grad_fn=<SoftmaxBackward>)
```

discret í•˜ë¯€ë¡œ, ì´ë¥¼ one-hot vectorë¡œ í‘œí˜„í•´ì£¼ì


```python
y_one_hot = torch.zeros_like(hypothesis)
y_one_hot.scatter_(1, y.unsqueeze(1), 1) #  ê°ê° dim = 1ì— ëŒ€í•´, y.unsqueeze(1)ì— 1ì„ ë¿Œë¦¬ê¸°
                                      ### ì¦‰, [0,2,1]ì´ ì•„ë˜ì™€ ê°™ì´ ë³€í•¨

#tensor([[1., 0., 0., 0., 0.],
#        [0., 0., 1., 0., 0.],
#        [0., 1., 0., 0., 0.]])

cost = (y_one_hot * -torch.log(hypothesis)).sum(dim=1).mean()
print(cost)
# tensor(1.4689, grad_fn=<MeanBackward1>)
```

ìœ„ì—ì„œ, `-torch.log(hypothesis))`ëŠ” (3,5)ì´ì§€ë§Œ, sum(dim=1)ì„ ì ìš©í•¨ìœ¼ë¡œì„œ (3,)ì´ ë¨

ì´í›„ mean()ì˜ ê²°ê³¼ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜


<br>

`model.nn` ì„ ì´ìš©í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤


```python
# Low level
torch.log(F.softmax(z, dim=1))

# High level
F.log_softmax(z, dim=1)

```

ë˜í•œ log LikelyhoodëŠ”

```python
# Low level
(y_one_hot * -torch.log(F.softmax(z, dim=1))).sum(dim=1).mean()
# tensor(1.4689, grad_fn=<MeanBackward1>)

# High level
F.nll_loss(F.log_softmax(z, dim=1), y)
#tensor(1.4689, grad_fn=<NllLossBackward>)
```


ì´ë•Œ NLLì€ Negative Log Likelyhood ì´ë‹¤.

ê·¸ëŸ¬ë‚˜ cross_entropy() ë¥¼ ì´ìš©í•˜ë©´ softmaxì™€ NLLì„ ëª¨ë‘ í•œë²ˆì— ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤


```python
F.cross_entropy(z, y)
#tensor(1.4689, grad_fn=<NllLossBackward>)
```


<br>


## Implementation


ì „ì²´ í•™ìŠµ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

ì•„ë˜ì˜ ê²½ìš°ëŠ” mê°œì˜ sample, 3ê°œì˜ class, 4-dimension ì´ë‹¤.


```python
x_train = [[1, 2, 1, 1],
           [2, 1, 3, 2],
           [3, 1, 3, 4],
           [4, 1, 5, 5],
           [1, 7, 5, 5],
           [1, 2, 5, 6],
           [1, 6, 6, 6],
           [1, 7, 7, 7]]
y_train = [2, 2, 2, 1, 1, 1, 0, 0]
x_train = torch.FloatTensor(x_train)
y_train = torch.LongTensor(y_train)

# ëª¨ë¸ ì´ˆê¸°í™”
W = torch.zeros((4, 3), requires_grad=True)
b = torch.zeros(1, requires_grad=True)
# optimizer ì„¤ì •
optimizer = optim.SGD([W, b], lr=0.1)

nb_epochs = 1000
for epoch in range(nb_epochs + 1):

    # Cost ê³„ì‚° (1)
    hypothesis = F.softmax(x_train.matmul(W) + b, dim=1) # or .mm or @
    y_one_hot = torch.zeros_like(hypothesis)
    y_one_hot.scatter_(1, y_train.unsqueeze(1), 1)
    cost = (y_one_hot * -torch.log(F.softmax(hypothesis, dim=1))).sum(dim=1).mean()

    # costë¡œ H(x) ê°œì„ 
    optimizer.zero_grad()
    cost.backward()
    optimizer.step()

    # 100ë²ˆë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥
    if epoch % 100 == 0:
        print('Epoch {:4d}/{} Cost: {:.6f}'.format(
            epoch, nb_epochs, cost.item()
        ))

```

ìœ„ì—ì„œ Cost ê³„ì‚° ë¶€ë¶„ë§Œ ì•„ë˜ ì½”ë“œë¡œ ëŒ€ì²´ ê°€ëŠ¥í•˜ë‹¤


```python
# Cost ê³„ì‚° (2)
z = x_train.matmul(W) + b # or .mm or @
cost = F.cross_entropy(z, y_train)
```

<br>


ë˜ëŠ” SoftmaxClassifierModel()ë¥¼ ì‚¬ìš©í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤



```python
model = SoftmaxClassifierModel()

# optimizer ì„¤ì •
optimizer = optim.SGD(model.parameters(), lr=0.1)

nb_epochs = 1000
for epoch in range(nb_epochs + 1):

    # H(x) ê³„ì‚°
    prediction = model(x_train)

    # cost ê³„ì‚°
    cost = F.cross_entropy(prediction, y_train)

    # costë¡œ H(x) ê°œì„ 
    optimizer.zero_grad()
    cost.backward()
    optimizer.step()

    # 20ë²ˆë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥
    if epoch % 100 == 0:
        print('Epoch {:4d}/{} Cost: {:.6f}'.format(
            epoch, nb_epochs, cost.item()
        ))
```

<br>
